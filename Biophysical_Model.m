%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% The following code simulates a single leaky integrate-and-fire neuron receiving
% excitatory and inhibitory inputs. These inputs are combined into input channels, 
% where each channel consists of a certain number of excitatory and inhibitory 
% synaptic weights. The input is generated by the function 
% InputGeneration_Biophysical_Model.m (see function for details) and is split into 
% two phases, a paired phase where only one randomly chosen channel receives Poisson
% input and an unpaired phase where all besides the previously paired channel receive
% Poisson input. Excitatory and inhibitory synaptic weights are modified based on spike
% -timing-dependent plasticity (STDP) rules (different for excitation and inhibition)
% which are implemented in the function STDP_Biophysical_Model.m (see function for details).
% In addition to this homosynaptic plasticity mechanism, heterosynaptic plasticity 
% is induced by decreasing the strongest excitatory and inhibitory input channel 
% based on a presynaptic input trace. Heterosynaptic plasticity is switched "on" 
% whenever the accumulated increase of the excitatory synaptic weights reaches 
% a certain threshold. If the accumualted weight-change falls below a second threshold, 
% heterosynaptic plasticity is switched "off".
%
%
% This code is the basis for the "biophysical model" in the manuscript:
%
% Heterosynaptic Plasticity Determines the Set-Point for Cortical Excitatory-
% Inhibitory Balance (2018)
% Rachel Field, James D'amour, Robin Tremblay, Christoph Miehl, Bernardo Rudy, 
% Julijana Gjorgjieva, Robert Froemke
% bioRxiv, doi: https://doi.org/10.1101/282012
%
%
% This code was used to generate Fig. 3D-E and Fig. S4B.
% An instance of this code runs 1-2 hours on a MacBookPro (2014 model). 
% To titrate the learning rate ratio of heterosynaptic vs homosynaptic plasticity 
% (as in Fig. 3F) change the values of eta_het_E and eta_het_I as in the
% README file. This requires writing an additional loop, which will require
% this code to be run a number of times (each 1-2 hours duration).
%
% This code was written to allow maximal flexibility. Most of the parameters of the
% homosynaptic plasticity, heterosynaptic plasticity, neuron model and input patterns
% can be changed easily in the code.
%
%
% The code was written by Christoph Miehl (christoph.miehl@brain.mpg.de).
% The concept was developed by Christoph Miehl and Julijana Gjorgjieva (gjorgjieva@brain.mpg.de).
% July 2018
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


clear all
rng('shuffle');

%% Parameters of the model

eta_het_E=1.3*10^(-5); % Learning rate of excitatory heterosynaptic plasticity
eta_het_I=1.3*10^(-4); % Learning rate of inhibitory heterosynaptic plasticity

% Accumulate eLTP variable and threshold for heterosynaptic eLTD and iLTD induction in absolute amount of weight-change.
thresh_hetLTD_on=0.7; % Upper threshold for accumulated plasticity. If acc_eLTP is above this value, heterosynaptic plasticity is "on".
thresh_hetLTD_off=0.1; % Lower threshold for accumulated plasticity. If acc_eLTP is below this value, heterosynaptic plasticity is "off".
tau_acc_eLTP=5*10^3; % Learning-dependent trace time constant (ms)

tau_trace_E=10^3; % Excitatory trace time constant (ms)
tau_trace_I=10^3; % Inhibitory trace time constant (ms)

% Parameters of the presynaptical neurons
channels=12; % Number of input channels
number_neurons_per_EI=10; % Number of excitatory/inhibitory neurons per channel
N_exc=channels*number_neurons_per_EI; % Number of total excitatory presynaptic neurons
N_inh=channels*number_neurons_per_EI; % Number of total inhibitory presynaptic neurons

FR_E_paired=75; % Excitatory firing rate during paired phase (Hz)
FR_I_paired=75; % Inhibitory firing rate during paired phase (Hz)
FR_E_unpaired=0.5; % Excitatory firing rate during unpaired phase (Hz)
FR_I_unpaired=0.5; % Inhibitory firing rate during unpaired phase (Hz)
 
bin_size=1500; % Length of the paired phase in ms
multiple_of_pairing=4; % Length of the unpaired phase is a multiple of the paired phase

% Parameters of the leaky integrate-and-fire postsynaptical neuron
tau_m=20; % Membrane time constant in ms
E_leak=-70; % Leak potential in mV
E_e=0; % Excitatory reversal potential in mV
E_i=-80; % Inhibitory reversal potential in mV
V_thresh=-50; % Threshold of the membrane potential when a spike is fired, in mV
V_reset=-70; % Value to which the membrane potential is reset after a spike, in mV
V=V_reset; % Initialization of postsynaptic neuron membrane voltage
tau_i=5; % Inhibitory conductance decay constant in ms
tau_e=5; % Excitatory conductance decay constant in ms

% Parameters of the excitatory STDP learning window
A_LTD_E=1; % Excitatory STDP learning amplitude (LTD)
A_LTP_E=1; % Excitatory STDP learning amplitude (LTP)
tau_LTP_E=20; % Time constant of eLTP in ms
tau_LTD_E=20; % Time constant of eLTD in ms
tau_w_E=10^3; % Weight time constant of excitatory STDP rule in ms

% Paramters of the inhibitory STDP learning window
A_LTD_I=1; % Inhibitory STDP learning amplitude (LTD)
A_LTP_I=1; % Inhibitory STDP learning amplitude (LTP)
tau_LTP_I=20; % Time constant of iLTP in ms
tau_LTD_I=20; % Time constant of iLTD in ms
tau_w_I=10^3; % Weight time constant if inhibitory STDP rule in ms

% Specify the time-resolution of the saved values
how_often_saving=500; % Save the specified parameters every how_often_saving (ms)

% Interval of initial weights 
iminE=0.2;
imaxE=0.35;
iminI=0.2;
imaxI=0.35;

% Lower and upper bounds for synaptic weights
% Note the upper bounds are never reached, this is jsut a precaution
W_min_E=0; % Minimal excitatory weight value
W_max_E=2000; % Maximal excitatory weight value
W_min_I=0; % Minimal inhibitory weight value
W_max_I=2000; % Maximal inhibitory weight value
bounds=[W_min_E,W_max_E,W_min_I,W_max_I]; % Bounds of the weights in a vector

% Time-parameters of the simulation:
dt=0.1; % Time step (in ms) of the simulation
end_sim=1000*60*80; % Length of the simulation (in ms)


%% Initialization of parameters
acc_eLTP=0; % Start value for accumulated excitatory LTP
counter_multiple_unpaired_phase=0; % Counter for multiple of the unpaired phase
heteroLTD_triggered_on_off=2; % Heterosynaptic plasticity is switched "off" at the beginning ("on" equals 1 and "off" equals 2)

g_E=zeros(N_exc,1); % Initializations of excitatory conductances
g_I=zeros(N_inh,1); % Initializations of inhibitory conductances
trace_each_E=zeros(N_exc,1); % Initializations of excitatory input traces
trace_each_I=zeros(N_inh,1); % Initializations of inhibitory input traces

type_of_input=2; % Start with the paired phase (type_of_input==1 defines the unpaired phase, type_of_input==2 the paired phase, see function InputGeneration_Biophysical_Model.m for details)
firing_rate_E=FR_E_paired; % Set the excitatory firing rate at the beginning to the value of the paired phase
firing_rate_I=FR_I_paired; % Set the inhibitory firing rate at the beginning to the value of the paired phase

r_E=zeros(N_exc,1); % Presynaptic spike detection
r_I=zeros(N_inh,1);
o_E=0; % Postsynaptic spike detection
o_I=0;

postsyn_spike_counter=0; % Counter for the number of spikes of the postsynaptic neuron

% Initialize average weights per channel
Channel_W_E=iminE+(imaxE-iminE).*rand(1,channels);
Channel_W_I=iminI+(imaxI-iminI).*rand(1,channels);

for uu=1:channels % Randomly choose initial values for each synaptic weight per channel
    for uu2=1:number_neurons_per_EI
        W_E(uu2+((uu-1)*number_neurons_per_EI),1)=Channel_W_E(uu)*(0.2*rand+0.9); %shift is within 10% from the channel value
        W_I(uu2+((uu-1)*number_neurons_per_EI),1)=Channel_W_I(uu)*(0.2*rand+0.9); %shift is within 10% from the channel value
    end
end

save_counter=1; % Counts the number of saved values
time_counter=1; % Counts the number of time steps
input_time_counter=1; % Counts the time within one input
save_W_exc(:,time_counter)=W_E; % Save initial excitatory weight values
save_W_inh(:,time_counter)=W_I; % Save initial inhibitory weight values

% Calculate the first inputs here
paired_channel_before=0; % Initialization of this parameter
[presyn_input_mat,paired_channel]=InputGeneration_Biophysical_Model(paired_channel_before,N_exc,N_inh,type_of_input,dt,firing_rate_E,firing_rate_I,bin_size,number_neurons_per_EI); % Generates the first input (see InputGeneration_Biophysical_Model.m for details)

input_counter_paired=1; % Counts the number of paired experiments
save_paired_channels(1,input_counter_paired)=paired_channel; % Saves the paired channels
input_counter_hetero=0; % Counts the number of unpaired experiments

% Calculate the initial E/I correlation between excitatory and inhibitory channels
for uu3=1:channels
    corre_E(uu3)=mean(save_W_exc(1+(uu3-1)*number_neurons_per_EI:uu3*number_neurons_per_EI,1));
    corre_I(uu3)=mean(save_W_inh(1+(uu3-1)*number_neurons_per_EI:uu3*number_neurons_per_EI,1));
end
[save_corr_val(1,1),p]=corr(corre_E',corre_I'); % Save the initial E/I correlation


%% Start of simulation
for tt=2*dt:dt:end_sim % time tt in ms
    
    
    % Alternate between paired and unpaired phases with durations specified above
    if (mod(time_counter,round(bin_size/dt)-1)==0) && (type_of_input==2)
        type_of_input=1; % Change to the unpaired phase after the paired phase
        firing_rate_E=FR_E_unpaired; % Change to the unpaired excitatory firing rate
        firing_rate_I=FR_I_unpaired; % Change to the unpaired inhibitory firing rate       
    elseif (type_of_input==1) && (counter_multiple_unpaired_phase>=multiple_of_pairing)
        type_of_input=2; % Change to the paired phase after the unpaired phase
        firing_rate_E=FR_E_paired; % Change to the paired excitatory firing rate
        firing_rate_I=FR_I_paired; % Change to the paired inhibitory firing rate
    end
    
    time_counter=time_counter+1; % Counts the timesteps
    input_time_counter=input_time_counter+1; % Counts the time for each input (gets reset to zero after one input is over)
    
    if V==0 % If there was a postsynaptic spike (the membrane potential is set to zero, see below), update the weights and reset the membrane potential
        V=V_reset; % Membrane potential is reset to V_reset
        postsyn_spike_counter=postsyn_spike_counter+1; % Counts the number of postsynaptic spikes
        pre_post=2; % Indicates that a postsynaptic spike happened
        
        % Update excitatory weights based on STDP rule
        E_or_I=1; % Update the excitatory weights
        W_E_old=W_E; % Dummy vector
        W_E=STDP_Biopysical_Model(W_E_old,tau_w_E,tau_w_I,r_E,o_E,A_LTD_E,A_LTD_I,A_LTP_E,A_LTP_I,pre_post,E_or_I,bounds); % Call STDP function (see STDP_Biopysical_Model.m for details)
        
        % Update the accumulated excitatory weight increase
        weight_diff=W_E-W_E_old;
        acc_eLTP=acc_eLTP+sum(weight_diff(weight_diff>0)); % Sum up the positive weight change per synaptic weight and add it to the accumulation value
        
        % Update inhibitory weights based on STDP rule
        E_or_I=2; % Update the inhibitory weights
        W_I=STDP_Biopysical_Model(W_I,tau_w_E,tau_w_I,r_I,o_I,A_LTD_E,A_LTD_I,A_LTP_E,A_LTP_I,pre_post,E_or_I,bounds); % Call STDP function (see STDP_Biopysical_Model.m for details)
        
        o_E=o_E+1; % Postsynaptic spike detector increase by +1 for an output spike
        o_I=o_I+1;
        
        
    else % Case where no postsynaptic spike was generated the timestep before
        
        % Change of excitatory variables
        g_E=g_E+W_E.*presyn_input_mat(1:N_exc,input_time_counter); % For each input spike, the excitatory conductance is increased by the amount of the weight value
        trace_each_E=trace_each_E+W_E.*presyn_input_mat(1:N_exc,input_time_counter); % For each input spike, the excitatory input trace is increased by the amount of the weight value
        r_E=r_E+presyn_input_mat(1:N_exc,input_time_counter); % Presynaptic spike detector increases by +1 for an input spike
        
        g_E=g_E+(g_E./tau_e.*dt).*(presyn_input_mat(1:N_exc,input_time_counter)-ones(N_exc,1)); % Conductance decreases if there is no input spike
        trace_each_E=trace_each_E+(trace_each_E./tau_trace_E.*dt).*(presyn_input_mat(1:N_exc,input_time_counter)-ones(N_exc,1)); % Input trace decreases if there is no input spike
        r_E=r_E+(r_E./tau_LTP_E.*dt).*(presyn_input_mat(1:N_exc,input_time_counter)-ones(N_exc,1)); % Presynaptic spike detector decreases if there is no input spike
        
        
        if sum(presyn_input_mat(1:N_exc,input_time_counter))>0 % Then there was an excitatory presynaptic spike at this timestep and the excitatory weights are updated

            pre_post=1; % Indicates that a presynaptic spike happened         
            E_or_I=1; % Update the excitatory weights
            W_E_old=W_E; % Dummy vector
            dummy_W_E=W_E.*presyn_input_mat(1:N_exc,input_time_counter); % Dummy vector
            dummy_W_E_new=STDP_Biopysical_Model(dummy_W_E,tau_w_E,tau_w_I,r_E,o_E,A_LTD_E,A_LTD_I,A_LTP_E,A_LTP_I,pre_post,E_or_I,bounds); % Call STDP function (see STDP_Biopysical_Model.m for details)
            W_E=dummy_W_E_new.*presyn_input_mat(1:N_exc,input_time_counter)+W_E.*(ones(N_exc,1)-presyn_input_mat(1:N_exc,input_time_counter));
            
            % Update the accumulated eLTP
            weight_diff=W_E-W_E_old;
            acc_eLTP=acc_eLTP+sum(weight_diff(weight_diff>0)); % Sum up the positive weight changs per synaptic weight and add it to the accumulation value           
        else % Accumulated eLTP decreases if there was weight change       
            acc_eLTP=acc_eLTP-acc_eLTP/tau_acc_eLTP*dt;
        end
        
        % Change of inhibitory variables
        g_I=g_I+W_I.*presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter); % For each input spike, the inhibitory conductance is increased by the amount of the weight value
        trace_each_I=trace_each_I+W_I.*presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter); % For each input spike, the inhibitory input trace is increased by the amount of the weight value
        r_I=r_I+presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter); % Presynaptic spike detector increases by +1 for an input spike
        
        g_I=g_I+(g_I./tau_i.*dt).*(presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter)-ones(N_inh,1)); % Conductance decreases if there is no input spike
        trace_each_I=trace_each_I+(trace_each_I./tau_trace_I.*dt).*(presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter)-ones(N_inh,1)); % Input trace decreases if there is no input spike
        r_I=r_I+(r_I./tau_LTP_I.*dt).*(presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter)-ones(N_inh,1)); % Presynaptic spike detector decreases if there is no input spike

        
        if sum(presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter))>0 % Then there was an inhibitory presynaptic spike at this timestep and the excitatory weights are updated
            pre_post_I=1; % Indicates that a presynaptic spike happened      
            E_or_I=2; % Update the inhibitory weights
            dummy_W_I=W_I.*presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter); % Dummy vector
            dummy_W_I=STDP_Biopysical_Model(dummy_W_I,tau_w_E,tau_w_I,r_I,o_I,A_LTD_E,A_LTD_I,A_LTP_E,A_LTP_I,pre_post_I,E_or_I,bounds); % Call STDP function (see STDP_Biopysical_Model.m for details)
            W_I=dummy_W_I.*presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter)+W_I.*(ones(N_inh,1)-presyn_input_mat(N_exc+1:N_exc+N_inh,input_time_counter));
        end
        
        % Calculate new membrane potential
        V=V+(E_leak-V+sum(g_E.*(E_e-V))+sum(g_I.*(E_i-V)))/tau_m*dt;
        
        % Postsynaptic detectors decrease if there was no postsynaptic spike
        o_E=o_E-o_E/tau_LTD_E*dt;
        o_I=o_I-o_I/tau_LTD_I*dt;
        
        if V>V_thresh % If V reaches threshold, a postsynaptic spike is fired
            V=0; % Set the membrane potential to zero, to see a "spike" when the membrane potential is plotted
        end
    end
    
    % Check if the accumulated eLTP is above (or below) the threshold to switch heterosynaptic plasticity "on" (or "off")
    if acc_eLTP>=thresh_hetLTD_on
        heteroLTD_triggered_on_off=1; % 1 means heterosynaptic plasticity is "on"
    elseif acc_eLTP<=thresh_hetLTD_off
        heteroLTD_triggered_on_off=2; % 2 means heterosynaptic plasticity is "off"
    end
    
    
    % Heterosynaptic plasticity
    if heteroLTD_triggered_on_off==1 % If heterosynaptic plasticity is "on", do the following
        
        for kkk=1:channels % Calculate the mean of the input traces per channel
            trace_channel_E(kkk,1)=mean(trace_each_E(1+(kkk-1)*number_neurons_per_EI:kkk*number_neurons_per_EI));
            trace_channel_I(kkk,1)=mean(trace_each_I(1+(kkk-1)*number_neurons_per_EI:kkk*number_neurons_per_EI));
        end
        
        % Calculate the maximum of the excitatory and the inhibitory channel
        [valE,maxE]=max(trace_channel_E);
        [valI,maxI]=max(trace_channel_I);
                
        % Choose the second maximum if the excitatory maximum is the paired channel
        if maxE==paired_channel
            [valE,maxE2]=max(trace_channel_E(trace_channel_E<max(trace_channel_E)));
            if maxE2>=paired_channel
                maxE=maxE2+1;
            else
                maxE=maxE2;
            end
        end
        % Choose the second maximum if the inhibitory maximum is the paired channel
        if maxI==paired_channel
            [valI,maxI2]=max(trace_channel_I(trace_channel_I<max(trace_channel_I)));
            if maxI2>=paired_channel 
                maxI=maxI2+1;
            else
                maxI=maxI2;
            end
        end
        
        % Change the synaptic weights corresponding to the maximal excitatory/inhibitory channels based on the presynaptic input trace
        W_E(1+(maxE-1)*number_neurons_per_EI:number_neurons_per_EI*maxE)=W_E(1+(maxE-1)*number_neurons_per_EI:number_neurons_per_EI*maxE)-trace_channel_E(maxE).*dt.*eta_het_E;
        W_I(1+(maxI-1)*number_neurons_per_EI:number_neurons_per_EI*maxI)=W_I(1+(maxI-1)*number_neurons_per_EI:number_neurons_per_EI*maxI)-trace_channel_I(maxI).*dt.*eta_het_I;
        
        % Check if due to heterosynaptic plasticity the weights are out of bound
        check_out_of_bound=(W_E>W_min_E & W_E<W_max_E); 
        check_out_of_bound2=(W_E<W_max_E); 
        check_out_of_bound3=(W_E>W_min_E); 
        W_E=W_E.*check_out_of_bound+(ones(length(W_E),1)-check_out_of_bound2).*W_max_E+(ones(length(W_E),1)-check_out_of_bound3).*W_min_E; 
        check_out_of_bound=(W_I>W_min_I & W_I<W_max_I); 
        check_out_of_bound2=(W_I<W_max_I);
        check_out_of_bound3=(W_I>W_min_I);
        W_I=W_I.*check_out_of_bound+(ones(length(W_I),1)-check_out_of_bound2).*W_max_I+(ones(length(W_I),1)-check_out_of_bound3).*W_min_I;
    end
    
    % Save weight values
    if mod(time_counter,round(how_often_saving/dt))==0
        save_counter=save_counter+1;
        save_W_exc(:,save_counter)=W_E;
        save_W_inh(:,save_counter)=W_I;
    end
    
    
    % Generate a new input after bin_size ms
    if (mod(time_counter,round(bin_size/dt))==0) && (tt<end_sim)
        input_time_counter=0; % Reset the input time counter
        [presyn_input_mat,paired_channel]=InputGeneration_Biophysical_Model(paired_channel,N_exc,N_inh,type_of_input,dt,firing_rate_E,firing_rate_I,bin_size,number_neurons_per_EI); % Generates new input (see InputGeneration_Biophysical_Model.m for details)
        
        if type_of_input==2 % Paired phase
            input_counter_paired=input_counter_paired+1; % Counts the number of paired phases
            save_paired_channels(1,input_counter_paired)=paired_channel; % Saves the paired channels
            
            % Calculate the E/I correlations at the end of the unpaired phase
            for xx=1:channels
                corre_E(xx)=mean(save_W_exc(1+(xx-1)*number_neurons_per_EI:xx*number_neurons_per_EI,save_counter));
                corre_I(xx)=mean(save_W_inh(1+(xx-1)*number_neurons_per_EI:xx*number_neurons_per_EI,save_counter));
            end           
            [save_corr_val(1,input_counter_paired),p]=corr(corre_E',corre_I'); % Save the E/I correlation value
            
            counter_multiple_unpaired_phase=0; % Reset the counter for multiple of the unpaired phase
            
        elseif type_of_input==1 % Unpaired phase                       
            counter_multiple_unpaired_phase=counter_multiple_unpaired_phase+1; % Counter for the unpaired phase
            input_counter_hetero=input_counter_hetero+1; % Input counter for heterosynaptic plasticity
        end
    end  
end

% Calculate the value at which the calculation of the correlation value is
% cut. This is important for the case of very strong heterosynaptic plasticity 
% when the weights gradually decrease to 0. If they reach a value 
% very close to 0, computing the E/I correlation no longer makes sense. 
% Also, we usually ignore the first few values to avoid biases in the
% calculation of the E/I correlations that are due to the initializations
% of the parameters in the model.
lower_cut_off_corr=10;
for hh2=1:length(save_W_exc(1,:))
    if mean(save_W_exc(:,hh2))<0.15
        upper_cut_off_corr=round(hh2/(bin_size*(multiple_of_pairing+1))*how_often_saving);
        break
    end
end

if hh2==length(save_W_exc(1,:))
    upper_cut_off_corr=round(hh2/(bin_size*(multiple_of_pairing+1))*how_often_saving);
end

mean_corr_value=mean(save_corr_val(1,lower_cut_off_corr:upper_cut_off_corr)); % This value is used in Fig 3F for different eta_het_E and eta_het_I values.

%% Plotting of the simulation results
figure(1)
subplot(2,3,1)
hold on
for pp2=1:channels
    mean_E_weight_plot(1,pp2)=mean(save_W_exc(1+(pp2-1)*number_neurons_per_EI:pp2*number_neurons_per_EI,1));
    mean_I_weight_plot(1,pp2)=mean(save_W_inh(1+(pp2-1)*number_neurons_per_EI:pp2*number_neurons_per_EI,1));
    scatter(pp2,mean_E_weight_plot(1,pp2),'b');
    scatter(pp2,mean_I_weight_plot(1,pp2),'r');
end
plot(1:channels,mean_E_weight_plot,'b')
plot(1:channels,mean_I_weight_plot,'r')
xlim([0.9 channels+0.1]);
hold off
xlabel('Stimulus channel')
ylabel('Synaptic strength (a.u.)')
legend('E channels','I channels')
title(['Start tuning curve, Corr: ' num2str(save_corr_val(1))])

subplot(2,3,4)
hold on
for pp2=1:channels
    mean_E_weight_plot(1,pp2)=mean(save_W_exc(1+(pp2-1)*number_neurons_per_EI:pp2*number_neurons_per_EI,end));
    mean_I_weight_plot(1,pp2)=mean(save_W_inh(1+(pp2-1)*number_neurons_per_EI:pp2*number_neurons_per_EI,end));
    scatter(pp2,mean_E_weight_plot(1,pp2),'b');
    scatter(pp2,mean_I_weight_plot(1,pp2),'r');
end
plot(1:channels,mean_E_weight_plot,'b')
plot(1:channels,mean_I_weight_plot,'r')
xlim([0.9 channels+0.1]);
hold off
xlabel('Stimulus channel')
ylabel('Synaptic strength (a.u.)')
legend('E channels','I channels')
title(['Start tuning curve, Corr: ' num2str(save_corr_val(end))])

subplot(2,3,2)
hold on
for jj=1:channels
    plot([1:how_often_saving:length(save_W_exc(1,:))*how_often_saving]./1000,mean(save_W_exc(1+(jj-1)*number_neurons_per_EI:jj*number_neurons_per_EI,:)))
end
hold off
xlabel('Time (s)')
ylabel('Synaptic strength (a.u.)')
title('Excitation')

subplot(2,3,5)
hold on
for jj2=1:channels
    plot([1:how_often_saving:length(save_W_inh(1,:))*how_often_saving]./1000,mean(save_W_inh(1+(jj2-1)*number_neurons_per_EI:jj2*number_neurons_per_EI,:)))
end
hold off
xlabel('Time (s)')
ylabel('Synaptic strength (a.u.)')
title('Inhibition')

subplot(2,3,3)
hold on
plot([1:bin_size*(multiple_of_pairing+1):length(save_corr_val(1,1:upper_cut_off_corr))*bin_size*(multiple_of_pairing+1)]/1000,save_corr_val(1,1:upper_cut_off_corr))
plot([1,length(save_corr_val(1,1:upper_cut_off_corr))*bin_size*(multiple_of_pairing+1)]./1000,[mean(save_corr_val(1,1:upper_cut_off_corr)),mean(save_corr_val(1,1:upper_cut_off_corr))])
hold off
xlabel('Time (s)')
ylabel('r-after')
title('Correlation - single run')
legend(['Mean correlation: ' num2str(mean_corr_value)])